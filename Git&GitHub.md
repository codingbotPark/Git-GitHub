> **패스트캠퍼스 Git & GitHub - 진유림 강사** 와 블로그 <a href = "https://myhappyman.tistory.com/54" target = "_blank" title = "참고자료">개발 흔적 남기기</a> 를 참고

# Git & GitHub

현대 팀 프로젝트에서 **버전관리**와 **클라우드 저장소**는 필수적인 기술이다  

<a href = "https://ko.wikipedia.org/wiki/%EA%B9%83_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)" target = "_blank" title = "참고자료">Git</a> 으로 버전관리를 할 수 있다  
<a href = "https://namu.wiki/w/GitHub" target = "_blank" title = "참고자료">GitHub</a> 는 클라우드 저장소이다  


<br>

# ch1. Git 과 버전관리

## 버전관리
원하는 지점마다 깃발을 꽂고(버전을 만들고) 이것들을 자유롭게 사용할 수 있다   
동료가 만든 버전으로 이동할 수 있고 버전들을 비교해서 최신본으로 업데이트를 할 수 있다  

<br>

## Git을 쓰려면 필요한 것
저장할 공간만 있다면 어디서나 사용이 가능하다
* 개인 컴퓨터
* USB
* 회사서버
* 클라우드 (GitHub, BitBucket, GitLab 등)

<br>

## Git을 사용하는 두 가지 방법
* CLI(Command Line Interface)
커맨드 창에 명령어를 친다
* GUI(Graphic User Interface)
버튼을 눌러 우리가 원하는 명령을 수행한다

CLI에 명령어를 쳐서 작동하는게 일반적이다  
이 것을 조금더 편하고 가시적으로 하기 위해 GUI가 

CLI는 Git이 제공하는 모든 기능을 사용할 수 있다 

<br>

## GitHub에 코드를 올리는 과정
1. 프로젝트 폴더에 이곳에 Git을 사용할 것을 명령 (git init)
1. 코딩
1. 내가 변경한파일 중 올리길 원하는 것만 선택 (git add)
1. 선택한 파일들을 한 덩이로 만들고 설명 적어주기 (git commit -m "설명")
1. GitHub 사이트에서 프로젝트 저장소 만들기 
1. 내 컴퓨터 프로젝트 폴더에 GitHub 저장소 주소 알려주기 (git remote add)
1. 내 컴퓨터에 만들었던 덩어리 GitHub에 올리기 (git push)

<br>

## Git & GitHub 환경 설정
### Git 설치
1. 명령 프롬프트에 `git` 을입력해서 내 컴퓨터에 Git이 설치되어 있는지 확인
1. 명령어에 대한 안내가 나오지 않으면  <a href = "https://git-scm.com/downloads" target = "_blank" title = "참고자료">Git 설치</a>
(설치할 때 Git Bash는 꼭 설치한다)

### Visual Studio Code 설치
Microsoft에서 제작한 무료 코드 에디터이다  
문법 강조, 코드 자동 완성, Git 연동 등 유용한 기능도 많고 오픈소스이다  

<a href = "https://code.visualstudio.com/download" target = "_blank" title = "참고자료">Visual Studio Code 설치</a>

### GitHub 가입
Git으로 버전 관리한 코드를 올릴 수 있는 클라우드 서버

<a href = "https://github.com/" target = "_blank" title = "참고자료">GitHub 가입</a>

Git 호스팅 사이트 | 모기업 | 특징 | 가격
:---:|:---:|---|---
GitHub|GitHub Inc(Microsoft에서 인수)|최대 규모의 Git 호스팅 사이트 | 공개 저장소 생성 무료, 비공개 저장소는 작업자 3인 이하인 경우에 무료, 설치형 버전인 Enterprise는 월 21달러
GitLab | GitLab inc | NASA, Sony 등 많은 조직이 사용, GitLab 자체가 오픈소스인 특징 | 공개, 비공개 저장소 생성 무료
BitBucket | Atlassian | 사용자 600만명, 지라(Jira)와 연동이 쉽다 | 5명 이하 팀이면 공개 및 비공개 저장소 생성 무료

<br> 

# ch2. Git & GitHub 시작하기 feat.GLI

GitHub에 코드를 올리는 과정

<br>

## 프로젝트 폴더에 Git을 쓴다는 명령
git init 을 한다  
git init 을 하면 .git의 폴더(숨김처리), 로컬 저장소가 나오게 된다  
이 로컬 저장소에서 버전관리 작업을 할 수 있다  
로컬 저장소를 직접적으로 만지는 경우는 없고 명령어를 통해 사용한다

프로젝트 폴더에서 Git 명령을 쓰는 관정

1. 원하는 폴더에서 Git 초기화를 한다
1. Git 초기화를 하면 .git 이라는 숨겨진 폴더(로컬 저장소)가 만들어진다
1. 로컬 저장소에 내가 만든 버전 정보, 원격 저장소 주소 등이 저장된다
1. 원격 저장소에서 내 컴퓨터로 코드를 받아오면 로컬 저장소가 자동으로 생긴다

**한 폴더에 하나의 로컬 저장소만 유지해야한다**  
.git을 만들고 원격 저장소에서 코드를 받아오면 또 .git이 생기기 때문에 충돌이 발생한다

### 로컬 저장소 생성 실습
1. 컴퓨터에 폴더 생성
1. Git Bash 로 만든 폴더에 들어가기     
1. git init 으로 로컬 저장소 생성

>순서대로 진행
git bash에 `pwd` 를 입력하면 현재 폴더를 알 수 있다  

`ls` 를 입력하면 현재 파일에 어떤 폴더와 어떤 파일이 있는지 알 수 있다  

다른 폴더를 선택하려면 `cd "들어갈폴더이름"` (change directory) 를 입력한다  

이 `pwd` , `ls` , `cd` 를 활용해 원하는 폴더에 접근한다  
생성한 빈 폴더에 접근하면 `ls` 를 입력했을 때 아무것도 출력되지 않는다

`git init` 을 입력한다
initialized impty Git repository in ~~ 가 출력된다  
빈 깃 레포지토리(로컬저장소)를 만들었다는 뜻이다  
`git init` 을 한 후에는 `(master)` 라는 단어가 추가되어있다

`ls -al` 을 출력하면 `.git` 파일이 보이다  
`.git`파일이은 레포지토리가 만들어 졌다는 뜻이다  
즉 숨겨진, 보이지않는 폴더를 볼 수 있게 해준다  

<br>

## 첫번째 버전 만들기

### 커밋(commit) = 하나의 버전  

페이지 1, 2, 3 작성 = commit,  
페이지 2 수정 = commit  
이런 버전들을 오갈 수 있다

### add = 커밋으로 만들길 원하는 파일만 선택
페이지 1, 2, 3 작성 = add,  
페이지 1, 2 선택 = commit  
결과적으로 커밋은 1, 2가 된다  

### 버전 생성 실습
1. VS Code에서 선택한 폴더에 README.md, index.html 파일 생성
1. 원하는 파일만 선택하기  
`git add README.md`
1. 메시지를 달아 커밋으로 만들기  
`git commit -m "프로젝트 설명 파일 추가"`
1. 생성한 커밋 보기  
`git log`

* git add . 을 하면 폴더에 있는 전체 파일을 추가할 수 있다

### 커밋특징
* 커밋은 '의미 있는 변동사항' 을 묶어서 만든다
* 만약 하나의 기능을 고치는데 5가지 파일을 수정했다면 그 5가지를 묶어서 하나의 커밋으로 만든다
* 개발자들이 어떤 파일을 수정했는지 손쉽게 파악할 수 있다
* 커밋 메시지를 적는게 관리하기 편하다

<br>

## 만든 버전 GitHub에 올리기 
GitHub에 만든 버전을 올려서 다른 사람들과 함께 버전 관리를 할 수 있다  

> 만든버전을 github에 올리려면 아래의 과정을 거쳐야 한다

GitHub 사이트에서 프로젝트 저장소 만들기  
내 컴퓨터 프로젝트 폴더에 GitHub 저장소 주소 알려주기 = `git remote add`  
내 컴퓨터에 만들었던 덩어리 GitHub에 올리기 = `git push`

### 원격 저장소 GitHub에서 만들고 커밋 푸쉬하기 실습
1. GitHub에 로그인해서 레포지토리 생성
1. 내 컴퓨터 로컬저장소폴더에 GitHub 저장소 주소 알려주기    
`git remote add origin https://github.com/아이디/이름.git`  
remote add = 원격저장소를 추가한다는 말이다  
origin = 원격저장소를 'origin' 이라는 이름 으로 추가한다는 말이다 (origin이 아닌 다른 이름도 된다)
1. 만든 커밋 푸쉬하기  
`git push origin master`  
'origin' 이라는 이름으로 리모트를 추가했기 때문에 'origin' 이다  
'master' = 브렌치라고 하는 개념이다 (기본 브렌티가 'master' 다)  
즉 'origin' 리모트에 'master' 브렌치에 커밋들이 올라가게 된다  
1. GitHub 사이트에서 올라간 커밋 확인  

* 외부 저장소 확인 = `git remote -v`

* 외부 저장소 삭제 =`git remote rm 저장소이름`  
즉 `git remote rm origin`


github의 우측상단에서 레포지토리를 생성할 수 있다  
* New repository = 새로운 저장소
* Import repository = 저장소 가져오기  
* New gist = 코드 조각을 올릴 때 사용  
저장소는 큰 단위의 폴더, 여러가지 코드가 모여있다
* New organization = 팀프로젝트 등을 할 때 팀이름으로 만들 수 있다  

README.md는 깃허브 저장소에 들어왔을 때 이 소스코드가 무엇을 하는지, 어떤 정보를 봤으면 좋겠는지 등을 요약하는 안내하는 역할을 한다

<br>

## 다른 사람이 만든 저장소 받아오기
원격 저장소를 내 컴퓨터에 받아는 것을 **클론 (clobe)** 이라 한다  
원격 저장소의 데이터를 가져오는 것을 **풀 (pull)** 이라 한다 

push 해서 원격저장소에 저장하고, pull 해서 원격저장소에 저장된 데이터를 가져온다  
push는 권한이 있어야 할 수 있기 때문에 레포지토리에 다른사람의 계정을 추가하면 다른사람에게도 권한이 생긴다  

### 클론(clone)하기 실습  
다른 폴더에 클론을 하는 실습

1. 클론할 폴더에 접근
`cd..` = 한단계 상위 폴더로 올라간다
1. 레포지토리주소 클론
레포지토리에 <span style = "color:green">CODE</a> 에서 주소를 복사할 수 있다  
`git clone 레포지토리주소 .`  
마지막에 `.` 은 현재 폴더를 의미하기 때문에 현재 폴더에 클론을 하겠다는 뜻이다  
`.` 을 붙이지 않는다면 새로운 폴더가 생기고 클론이 된다  

* 다른사람의 레포지토리에 기여를 하려면 권한이 있어야 한다  
**레포지토리의 settings 에 왼쪽 Manage access 에서 추가를 해야한다**

### 풀(pull)하기 실습
원격저장소의 변경을 로컬저장소로 풀하는 실습

1. 풀할 폴더에 접근
`cd../` 한 단계 상위 폴더에서 선택한다
1. 풀하기
`git pull 저장소명` 의 형태
`git pull origin master`   

<br>
 
# ch3. Git & GitHub 다지기 feat.GUI

## Add 와 Commit
* 커밋이란 하나의 최종 코드모음이다
* 기존 커밋과 비교해서 변경된 팔일이 아니면 '변경되지 않았다' 고만 저장해서 용량이 무겁지 않다

작업공간에서 **add** 로 로컬저장소의 스테이지로 가고  
스테이지에서 **commit** 으로 프로젝트를 저장한다  

* Git으로 추적하는 파일의 4가지 형태에는  
    * 추적 안됨
    * 수정 없음
    * 수정함
    * 스테이지됨
* 작업공간에 있는 **수정함** , **추적 안됨** 파일을 스테이지로 올려 **스테이지됨** 으로 변경한다
* 커밋을 하면 **수정 없음** 상태로 돌아가서 다시 파일을 수정할 수 있다

## Branch
1번이 `고양1 - 고양2 - 고양3` 을 커밋했고,  
2번이 `고양1 - 고양2 - 문어1` 을 커밋했다면  
한 줄로 커밋을 쌓으면 둘이 겹치지 않고  
공통적인 `고양2` 에서 나뭇 가지(branch) 같이 두 개의 버전으로 뻗어간다 

그렇다면 왜 같이 작업하려면 여러 줄로 커밋을 쌓아야 할까  
**한 줄에서 작업하면 충돌이 날 수 있다**  
**똑같은 코드를 동시에 고칠 가능성이 있다**

사실 브랜치는 이미 있었다  
푸쉬에서 `git push origin master` 에서 `master` 는  'master 브랜치에 커밋을 푸시해라' 라는 뜻이었다  

```
`버전1` -> `버전2` -> `버전3`  
                      /
               master 브랜치 <- head
```

`버전1` -> `버전2` -> `버전3` 에서 master브랜치가 `버전3` 을 가르키고 있고 이 master브랜치는 head가 또 가르키고 있다  

head는 내가 지금 작업하는 로컬 브랜치를 가르킨다  
그래서 100개의 브랜치가 있더라도 내가 지금 어떤 브랜치에 있는지 알 수 있다  

### 브랜치를 만드는 법
`git branch 브랜치이름` 의 형태로 branch를 만들 수 있다  
`git branch cat` 이라면 'cat브랜치를 현재 시점에 만들어라' 라는 뜻이다  

### Head를 만드는 법
`git checkout 브랜치이름` 의 형태로 branch를 만들 수 있다  
`git chechout cat` 이라면 'cat브랜치로 Head를 이동해라' 라는 뜻이다

<br>

## merge
두 버전을 합칠 수 있다

베이스가 될 프랜치에 이동을 해야한다(head를 옮겨야 한다)   
베이스에서 머지를 한다면 결과는 브랜치의 커밋이다

<br>

## Conflict
두 버전을 합치는 머지를 하다가 충돌이 날 수 있다   
이 충돌된 상태가 conflict이다  

* 두 버전이 같은 곳을 수정했다면 이를 수동으로 고쳐줘야 한다

<br>

## Fork
저장소를 통째로 복제할 수 있다  
원본이 안전하게 저장되어 있어서 더 자유롭게 푸쉬를 할 수 있다  

### 브랜치와의 차이점
두 가지 모두 코드를 협업하기 위해 분기점을 나누는 방식이지만 특성이 다르다

키워드 | 의의 | 편리한 점 | 불편한 점
:---:|---|---|---|
브랜치 |하나의 원본저장소에서 분기를 나눈다 | 원본저장소에서 코드 커밋 이력을 편하게 볼 수 있다 | 다수의 사용자가 다수의 브랜치를 만들면 관리하기 힘들다
포크|여러 원격저장소를 만들어 분기를 나눈다|원본저장소에 영향을 미치지 않아서 코드 수정을 자유롭게 할 수 있다|원본저장소의 이력을 보려면 따로 주소를 추가해줘야 한다

<br>

## Pull request
커밋과 커밋을 합치는 것을 허락해주는 것을 풀 리퀘스트라고 한다   
 

* 코드를 함께 작성하는 팀원이 있다면, **직접 머지하는건 피하고** 모든 머지를 **풀 리퀘스트**를 통해서 해야한다
* 동료가 내 풀 리퀘스트를 보고 **코드리뷰**를 할 수 있다
* 동료의 풀 리퀘스트에 수정이 필요하면 댓글을 달아 change request를 보낼 수 있다


풀리퀘스트를 받으면 Files changed > Review changes 에  
* Comment = 그저 댓글만 달기
* Approve = 머지되도 된다는 승인
* Request changes = 이 풀리퀘스트에 어떤 점을 고치면 좋겠다

머지 풀 리퀘스트를 하면 머지가 된다

<br>

## +

### 브랜치 관리
* 보통 `feat/기능이름` 으로 한 사람이 개발하는 기능 브랜치를 만든다 (`fix/버그이름` , `hotfix/급한버그` 등 도 있다)
* 작업이 끝나면 `dev` (또는 `master`) 브랜치로 풀리퀘스트를 보낸다
* `dev` 브랜치에서 큰 작업이 모두 머지되면 `release` (또는 `latest`) 브랜치로 머지시키고 이를 실서버에 배포한다
* 직접 커밋은 feat (또는 `fix` , `hotfix`) 브랜치에만 한다
* `dev` , `master` , `release` 브랜치에는 직접 커밋하지 말고 머지만 한다

### 다른 깃의 명령어들
> 키워드
* `rebase` = 묵은 커밋을 새 커밋처럼 조작할 수 있다
* `amend` = 커밋을 하고 수정 못 한 파일이 있을 때 새로운 커밋을 만들지 않고 방금만든 커밋에 살짝 추가할 수 있다
* `cherry-pick` = 커밋 하나만 떼서 지금 브랜치에 붙일 수 있다
* `reset` = 옛날 커밋으로 시간을 돌릴 수 있다  
과거의 커밋을 리셋하면 원격저장소에서도 과거 커밋으로 보인다
* `reverse` = 커밋의 변경사항을 돌리 수 있다
* `stash` = 변경사항을 잠시 킵해두고 커밋은 만들지 않을 수 있다  